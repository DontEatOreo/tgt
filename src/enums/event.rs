use std::str::FromStr;

use crossterm::event::{KeyCode, KeyModifiers, MouseEvent};

use crate::app_error::AppError;

#[derive(Debug, Clone, Eq, Hash, PartialEq)]
/// `Event` is an enum that represents the different types of events that can be
/// generated by the intraction with the terminal (`tui_backend`).
/// These events are used to drive the user interface and the application logic
/// and should be handled entirely.
pub enum Event {
    /// Unknown event.
    Unknown,
    /// Init event.
    Init,
    /// Quit event.
    Quit, // Not used
    /// Render event.
    Render,
    /// Resize event with width and height.
    Resize(u16, u16),
    /// Key event with a `KeyCode` and `KeyModifiers`.
    Key(KeyCode, KeyModifiers),
    /// Mouse event with a `MouseEvent` struct.
    Mouse(MouseEvent),
}
/// Implement the `Event` enum.
impl Event {
    pub fn event_with_modifiers(
        s: &str,
        modifiers: KeyModifiers,
    ) -> Result<Event, AppError> {
        match s {
            "backspace" => Ok(Event::Key(KeyCode::Backspace, modifiers)),
            "enter" => Ok(Event::Key(KeyCode::Enter, modifiers)),
            "left" => Ok(Event::Key(KeyCode::Left, modifiers)),
            "right" => Ok(Event::Key(KeyCode::Right, modifiers)),
            "up" => Ok(Event::Key(KeyCode::Up, modifiers)),
            "down" => Ok(Event::Key(KeyCode::Down, modifiers)),
            "home" => Ok(Event::Key(KeyCode::Home, modifiers)),
            "end" => Ok(Event::Key(KeyCode::End, modifiers)),
            "page_up" => Ok(Event::Key(KeyCode::PageUp, modifiers)),
            "page_down" => Ok(Event::Key(KeyCode::PageDown, modifiers)),
            "tab" => Ok(Event::Key(KeyCode::Tab, modifiers)),
            "back_tab" => Ok(Event::Key(KeyCode::BackTab, modifiers)),
            "delete" => Ok(Event::Key(KeyCode::Delete, modifiers)),
            "insert" => Ok(Event::Key(KeyCode::Insert, modifiers)),
            "null" => Ok(Event::Key(KeyCode::Null, modifiers)),
            "esc" => Ok(Event::Key(KeyCode::Esc, modifiers)),
            "f1" => Ok(Event::Key(KeyCode::F(1), modifiers)),
            "f2" => Ok(Event::Key(KeyCode::F(2), modifiers)),
            "f3" => Ok(Event::Key(KeyCode::F(3), modifiers)),
            "f4" => Ok(Event::Key(KeyCode::F(4), modifiers)),
            "f5" => Ok(Event::Key(KeyCode::F(5), modifiers)),
            "f6" => Ok(Event::Key(KeyCode::F(6), modifiers)),
            "f7" => Ok(Event::Key(KeyCode::F(7), modifiers)),
            "f8" => Ok(Event::Key(KeyCode::F(8), modifiers)),
            "f9" => Ok(Event::Key(KeyCode::F(9), modifiers)),
            "f10" => Ok(Event::Key(KeyCode::F(10), modifiers)),
            "f11" => Ok(Event::Key(KeyCode::F(11), modifiers)),
            "f12" => Ok(Event::Key(KeyCode::F(12), modifiers)),
            e => {
                if e.len() == 1 && e.chars().next().unwrap().is_ascii() {
                    Ok(Event::Key(
                        KeyCode::Char(e.chars().next().unwrap()),
                        modifiers,
                    ))
                } else {
                    Err(AppError::InvalidEvent(e.to_string()))
                }
            }
        }
    }
}

/// Implement the `FromStr` trait for `Event`.
impl FromStr for Event {
    type Err = AppError;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Ok(event) = Self::event_with_modifiers(s, KeyModifiers::NONE) {
            Ok(event)
        } else if s.starts_with("ctrl+") {
            Self::event_with_modifiers(
                s.trim_start_matches("ctrl+"),
                KeyModifiers::CONTROL,
            )
        } else if s.starts_with("alt+") {
            Self::event_with_modifiers(
                s.trim_start_matches("alt+"),
                KeyModifiers::ALT,
            )
        } else if s.starts_with("shift+") {
            Self::event_with_modifiers(
                s.trim_start_matches("shift+"),
                KeyModifiers::SHIFT,
            )
        } else {
            Err(AppError::InvalidEvent(s.to_string()))
        }
    }
}
